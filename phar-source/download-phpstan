#!/usr/bin/env php
<?php declare(strict_types=1);

use splitbrain\PHPArchive\Zip;

$yellow  = "\033[33m";
$reset   = "\033[0m"; // resets to default color

$warning = "\n";
$warning .= "   " . $yellow . "[WARNING] You're prefering source installation instead of dist installation" . $reset . PHP_EOL;
$warning .= "             " . $yellow . "of phpstan/phpstan. Normally it'd lead to downloading multiple GBs" . $reset . PHP_EOL;
$warning .= "             " . $yellow . "but we made precautions to avoid that." . $reset . PHP_EOL;
$warning .= "\n";
$warning .= "             " . $yellow . "You're now using a special Git repository just for the purpose." . $reset . PHP_EOL;
$warning .= "             " . $yellow . "of saving you data." . $reset . PHP_EOL;
$warning .= "             " . $yellow . "This script downloads phpstan.phar for you and runs it." . $reset . PHP_EOL;
$warning .= "\n";
$warning .= "             " . $yellow . "We recommend you to switch to dist installation in any case." . $reset . PHP_EOL;
$warning .= "\n";
$warning .= "             " . $yellow . "Learn more:" . $reset . PHP_EOL;
$warning .= "             " . 'https://github.com/phpstan/phpstan-phar-composer-source';
$warning .= "\n";
$warning .= "\n";

fwrite(STDERR, $warning);

function deleteDirectoryWithContents(string $path): void {
	$iterator = new RecursiveDirectoryIterator($path);
	$iterator->setFlags(RecursiveDirectoryIterator::SKIP_DOTS);
	$files = new RecursiveIteratorIterator($iterator);
	foreach ($files as $file) {
		@unlink($file->getPathname());
	}

	@rmdir($path . '/conf');
	@rmdir($path);
}

$pharRunning = \Phar::running(false);
if ($pharRunning === '') {
	$root = __DIR__ . '/..';
	$vendorDir = $root . '/vendor';
} else {
	$root = dirname($pharRunning);
	$vendorDir = $root . '/../..';
}
$phpstanPharPath = $root . '/phpstan-downloaded.phar';

$getVersion = function () use ($vendorDir) {
	$installedJsonPath = $vendorDir . '/composer/installed.json';
	if (!is_file($installedJsonPath)) {
		echo "Could not find installed.json\n";
		exit(1);
	}

	$installedJsonContents = @file_get_contents($installedJsonPath);
	if ($installedJsonContents === false) {
		echo "Could not read installed.json\n";
		exit(1);
	}

	$installedJson = json_decode($installedJsonContents, true, 512, JSON_THROW_ON_ERROR);
	foreach ($installedJson['packages'] as $package) {
		if ($package['name'] !== 'phpstan/phpstan') {
			continue;
		}

		$phpstanVersion = $package['version'];
		if (preg_match('/^\d+\.\d+\.\d+$/', $phpstanVersion) === 1) {
			return $phpstanVersion;
		}

		break;
	}

	return '2.1.27';
};

$downloadPhpstan = function (string $version) use ($root, $phpstanPharPath) {
	$zip = @file_get_contents(sprintf('https://github.com/phpstan/phpstan/archive/refs/tags/%s.zip', $version));
	if ($zip === false) {
		echo "Download was not successful\n";
		exit(1);
	}

	$tempPath = $root . '/temp.zip';
	$putRes = @file_put_contents($tempPath, $zip);
	if ($putRes === false) {
		echo "Could not save temp.zip\n";
		exit(1);
	}

	$autoloader = require_once __DIR__ . '/vendor/autoload.php';

	fwrite(STDERR, "Unzipping PHPStan...\n");
	$zip = new Zip();
	$zip->open($tempPath);
	$phpstanDirPath = null;
	foreach ($zip->contents() as $file) {
		if (!$file->getIsdir()) {
			continue;
		}

		$phpstanDirPath = $file->getPath();
		break;
	}

	if ($phpstanDirPath === null) {
		echo "Could not find phpstan path in the zip\n";
		@unlink($tempPath);
		exit(1);
	}

	$zip = new Zip();
	$zip->open($tempPath);
	$zip->extract($root);

	$autoloader->unregister();

	$resCopy = copy($root . '/' . $phpstanDirPath . '/phpstan.phar', $root . '/phpstan-downloaded.phar');
	@unlink($tempPath);
	deleteDirectoryWithContents($root . '/' . $phpstanDirPath);

	if ($resCopy === false) {
		echo "Could not find copy phpstan.phar\n";
		exit(1);
	}
};

$version = $getVersion();

if (!file_exists($phpstanPharPath)) {
	fwrite(STDERR, "Downloading PHPStan...\n");
	$downloadPhpstan($version);
} else {
	exec(implode(' ', [
		escapeshellarg(PHP_BINARY),
		escapeshellarg($phpstanPharPath),
		'--version',
	]), $versionOutput, $versionExitCode);
	$versionLine = implode("\n", $versionOutput);
	$currentVersion = substr($versionLine, strlen('PHPStan - PHP Static Analysis Tool '));

	if ($version !== $currentVersion) {
		fwrite(STDERR, sprintf("PHPStan %s is on disk, downloading PHPStan %s...\n", $currentVersion, $version));
		$downloadPhpstan($version);
	}
}

Phar::loadPhar($phpstanPharPath, 'phpstan.phar');
require 'phar://' . $phpstanPharPath . '/bin/phpstan';
